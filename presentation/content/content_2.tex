\section{MPC and GP-MPC Learning}

\begin{frame}{Model Predicitve control}
    \begin{itemize}
        \item Model Predictive Control (MPC) is an advanced control method that uses a model of the system to predict and optimize the control actions over a future time horizon.
        % \item MPC relies on a dynamic model of the process being controlled.
        \item MPC operates on a receding horizon principle 
        % where it repeatedly solves a finite horizon optimal control problem (OCP) at each time step.
        \item directly address State and input constraints
        % Unlike many other control methods, MPC can directly address constraints on the input, state, and output during the design process, enhancing its applicability in practical scenarios.
        \item the high computational cost of solving the OCP
        % One of the main challenges of MPC is the high computational cost of solving the OCP within the sampling time.

        
    \end{itemize}
     \begin{figure}[ht]		% h - here, t - top, b - bottom, p - page, ! - try hard
        \centering
        \afig{0.5}{figures/GP/mpc}			% {scaling}{Figure from MATLAB, picture, etc.}
        \caption{MPC Illustration\cite{maiworm2021gaussian}}
        % \caption{MPC Illustration: For a particular initial condition $x_k$ at time instant $k$, a predicted open-loop sequence of inputs $\hat{u}$ is computed up to a prediction horizon $N$. The input sequence, together with the resulting predicted states $\hat{x}$, are computed in such a way that they minimize a given cost\cite{maiworm2021gaussian}.}
        \label{f:figure_mpc}
    \end{figure}
\end{frame}




% \begin{frame}{Model Predicitve control \cite{maiworm2021gaussian}}
%      \begin{figure}[ht]		% h - here, t - top, b - bottom, p - page, ! - try hard
%         \centering
%         \afig{0.9}{figures/GP/mpc}			% {scaling}{Figure from MATLAB, picture, etc.}
%         % \caption{MPC Illustration: For a particular initial condition $x_k$ at time instant $k$, a predicted open-loop sequence of inputs $\hat{u}$ is computed up to a prediction horizon $N$. The input sequence, together with the resulting predicted states $\hat{x}$, are computed in such a way that they minimize a given cost\cite{maiworm2021gaussian}.}
%         \label{f:figure_mpc}
%     \end{figure}
% \end{frame}





% \begin{frame}{Model Predicitve control}
%     The basic procedure applied by a model predictive control scheme can be illustrated in Figure \ref{f:figure_mpc} and summarized as follows:

%     \begin{enumerate}
%         \item Obtain the state $x_k$ at the current time step $k$.
%         \item Formulate and solve a finite horizon optimal control problem. This involves predicting the future evolution of the system and determining an optimal input sequence that minimizes a given cost function over a finite prediction horizon.
%         \item Apply the first part of the optimal input sequence to the system. 
%         \item Repeat, go back to Step 1.
%     \end{enumerate}
% \end{frame}





\begin{frame}{GP-MPC framework}
    \centering
    \begin{tikzpicture}[node distance=2cm, auto, thick, >=triangle 45]
    % Define block styles
    \tikzstyle{block} = [rectangle, draw, fill=blue!20, 
        text width=13em, text centered, rounded corners, minimum height=1.5em, font=\scriptsize]
    \tikzstyle{line} = [draw, -latex']
    
    % Define nodes
    \node [block] (init) {Initialization: - GP Parameters\\- MPC Parameters,  - Data Set};
    \node [block, below of=init, node distance=0.95cm] (recursion) { $i \leftarrow 1$ to $N$};
    \node [block, below of=recursion, node distance=0.9cm] (in) {$u_0 = u^*(1)$};
    \node [block, below of=in, node distance=1cm] (train) {Train the GP Model\\- Optimize $\theta$ \\-Predict mean and covariance};
    \node [block, below of=train, node distance=1.5cm] (mpc) {MPC Design\\- Long-term prediction\\- Compute cost function\\- Formulate and solve OCP};
    
    \node [block, below of=mpc, node distance=1.6cm] (update) {Update\\- Apply $u_0 = u^*(1)$ \\- Add new GP data point};
    
    % Draw edges
    \path [line] (init) -- (recursion);
    \path [line] (recursion) -- (in);
    \path [line] (in) -- (train);
    \path [line] (train) -- (mpc);
    \path [line] (mpc) -- (update);
    \path [line] (update.south) -- ++(0,-0.1) -| ++(3,0) |- ++(0,2) |- ++(0,2) |- (recursion.east);

    \end{tikzpicture}
\end{frame}































% \begin{frame}	\frametitle{What I want to do}
% 	\begin{itemize}
% 		\item Continue reading and filling the table
% 		\item Think about how to include consensus? (Flocking, or other ideas?!) \cite{EiHoWe13d,ElAh07}
% 		\item if using a "global" costfunction, how to cope with iterations, are they avoidable to some extent?
% 	\end{itemize}
% \end{frame}